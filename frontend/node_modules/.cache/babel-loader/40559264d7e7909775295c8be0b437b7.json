{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isFullComment = exports.isFullUser = exports.isFullDatabase = exports.isFullPage = exports.isFullBlock = exports.collectPaginatedAPI = exports.iteratePaginatedAPI = void 0;\n/**\n * Returns an async iterator over the results of any paginated Notion API.\n *\n * Example (given a notion Client called `notion`):\n *\n * ```\n * for await (const block of iteratePaginatedAPI(notion.blocks.children.list, {\n *   block_id: parentBlockId,\n * })) {\n *   // Do something with block.\n * }\n * ```\n *\n * @param listFn A bound function on the Notion client that represents a conforming paginated\n *   API. Example: `notion.blocks.children.list`.\n * @param firstPageArgs Arguments that should be passed to the API on the first and subsequent\n *   calls to the API. Any necessary `next_cursor` will be automatically populated by\n *   this function. Example: `{ block_id: \"<my block id>\" }`\n */\n\nasync function* iteratePaginatedAPI(listFn, firstPageArgs) {\n  let nextCursor = firstPageArgs.start_cursor;\n\n  do {\n    const response = await listFn({ ...firstPageArgs,\n      start_cursor: nextCursor\n    });\n    yield* response.results;\n    nextCursor = response.next_cursor;\n  } while (nextCursor);\n}\n\nexports.iteratePaginatedAPI = iteratePaginatedAPI;\n/**\n * Collect all of the results of paginating an API into an in-memory array.\n *\n * Example (given a notion Client called `notion`):\n *\n * ```\n * const blocks = collectPaginatedAPI(notion.blocks.children.list, {\n *   block_id: parentBlockId,\n * })\n * // Do something with blocks.\n * ```\n *\n * @param listFn A bound function on the Notion client that represents a conforming paginated\n *   API. Example: `notion.blocks.children.list`.\n * @param firstPageArgs Arguments that should be passed to the API on the first and subsequent\n *   calls to the API. Any necessary `next_cursor` will be automatically populated by\n *   this function. Example: `{ block_id: \"<my block id>\" }`\n */\n\nasync function collectPaginatedAPI(listFn, firstPageArgs) {\n  const results = [];\n\n  for await (const item of iteratePaginatedAPI(listFn, firstPageArgs)) {\n    results.push(item);\n  }\n\n  return results;\n}\n\nexports.collectPaginatedAPI = collectPaginatedAPI;\n/**\n * @returns `true` if `response` is a full `BlockObjectResponse`.\n */\n\nfunction isFullBlock(response) {\n  return \"type\" in response;\n}\n\nexports.isFullBlock = isFullBlock;\n/**\n * @returns `true` if `response` is a full `PageObjectResponse`.\n */\n\nfunction isFullPage(response) {\n  return \"url\" in response;\n}\n\nexports.isFullPage = isFullPage;\n/**\n * @returns `true` if `response` is a full `DatabaseObjectResponse`.\n */\n\nfunction isFullDatabase(response) {\n  return \"title\" in response;\n}\n\nexports.isFullDatabase = isFullDatabase;\n/**\n * @returns `true` if `response` is a full `UserObjectResponse`.\n */\n\nfunction isFullUser(response) {\n  return \"type\" in response;\n}\n\nexports.isFullUser = isFullUser;\n/**\n * @returns `true` if `response` is a full `CommentObjectResponse`.\n */\n\nfunction isFullComment(response) {\n  return \"created_by\" in response;\n}\n\nexports.isFullComment = isFullComment;","map":{"version":3,"mappings":";;;;;;AAwBA;;;;;;;;;;;;;;;;;;;;AAmBO,gBAAgBA,mBAAhB,CACLC,MADK,EAELC,aAFK,EAEc;EAEnB,IAAIC,UAAU,GAA8BD,aAAa,CAACE,YAA1D;;EACA,GAAG;IACD,MAAMC,QAAQ,GAAwB,MAAMJ,MAAM,CAAC,EACjD,GAAGC,aAD8C;MAEjDE,YAAY,EAAED;IAFmC,CAAD,CAAlD;IAIA,OAAOE,QAAQ,CAACC,OAAhB;IACAH,UAAU,GAAGE,QAAQ,CAACE,WAAtB;EACD,CAPD,QAOSJ,UAPT;AAQD;;AAbDK;AAeA;;;;;;;;;;;;;;;;;;;AAkBO,eAAeC,mBAAf,CACLR,MADK,EAELC,aAFK,EAEc;EAEnB,MAAMI,OAAO,GAAW,EAAxB;;EACA,WAAW,MAAMI,IAAjB,IAAyBV,mBAAmB,CAACC,MAAD,EAASC,aAAT,CAA5C,EAAqE;IACnEI,OAAO,CAACK,IAAR,CAAaD,IAAb;EACD;;EACD,OAAOJ,OAAP;AACD;;AATDE;AAWA;;;;AAGA,SAAgBI,WAAhB,CACEP,QADF,EAC4D;EAE1D,OAAO,UAAUA,QAAjB;AACD;;AAJDG;AAMA;;;;AAGA,SAAgBK,UAAhB,CACER,QADF,EAC0D;EAExD,OAAO,SAASA,QAAhB;AACD;;AAJDG;AAMA;;;;AAGA,SAAgBM,cAAhB,CACET,QADF,EACkE;EAEhE,OAAO,WAAWA,QAAlB;AACD;;AAJDG;AAMA;;;;AAGA,SAAgBO,UAAhB,CACEV,QADF,EAC0D;EAExD,OAAO,UAAUA,QAAjB;AACD;;AAJDG;AAMA;;;;AAGA,SAAgBQ,aAAhB,CACEX,QADF,EACgE;EAE9D,OAAO,gBAAgBA,QAAvB;AACD;;AAJDG","names":["iteratePaginatedAPI","listFn","firstPageArgs","nextCursor","start_cursor","response","results","next_cursor","exports","collectPaginatedAPI","item","push","isFullBlock","isFullPage","isFullDatabase","isFullUser","isFullComment"],"sources":["/home/tan/flash-card/node_modules/@notionhq/client/src/helpers.ts"],"sourcesContent":["import {\n  BlockObjectResponse,\n  CommentObjectResponse,\n  DatabaseObjectResponse,\n  PageObjectResponse,\n  PartialBlockObjectResponse,\n  PartialCommentObjectResponse,\n  PartialDatabaseObjectResponse,\n  PartialPageObjectResponse,\n  PartialUserObjectResponse,\n  UserObjectResponse,\n} from \"./api-endpoints\"\n\ninterface PaginatedArgs {\n  start_cursor?: string\n}\n\ninterface PaginatedList<T> {\n  object: \"list\"\n  results: T[]\n  next_cursor: string | null\n  has_more: boolean\n}\n\n/**\n * Returns an async iterator over the results of any paginated Notion API.\n *\n * Example (given a notion Client called `notion`):\n *\n * ```\n * for await (const block of iteratePaginatedAPI(notion.blocks.children.list, {\n *   block_id: parentBlockId,\n * })) {\n *   // Do something with block.\n * }\n * ```\n *\n * @param listFn A bound function on the Notion client that represents a conforming paginated\n *   API. Example: `notion.blocks.children.list`.\n * @param firstPageArgs Arguments that should be passed to the API on the first and subsequent\n *   calls to the API. Any necessary `next_cursor` will be automatically populated by\n *   this function. Example: `{ block_id: \"<my block id>\" }`\n */\nexport async function* iteratePaginatedAPI<Args extends PaginatedArgs, Item>(\n  listFn: (args: Args) => Promise<PaginatedList<Item>>,\n  firstPageArgs: Args\n): AsyncIterableIterator<Item> {\n  let nextCursor: string | null | undefined = firstPageArgs.start_cursor\n  do {\n    const response: PaginatedList<Item> = await listFn({\n      ...firstPageArgs,\n      start_cursor: nextCursor,\n    })\n    yield* response.results\n    nextCursor = response.next_cursor\n  } while (nextCursor)\n}\n\n/**\n * Collect all of the results of paginating an API into an in-memory array.\n *\n * Example (given a notion Client called `notion`):\n *\n * ```\n * const blocks = collectPaginatedAPI(notion.blocks.children.list, {\n *   block_id: parentBlockId,\n * })\n * // Do something with blocks.\n * ```\n *\n * @param listFn A bound function on the Notion client that represents a conforming paginated\n *   API. Example: `notion.blocks.children.list`.\n * @param firstPageArgs Arguments that should be passed to the API on the first and subsequent\n *   calls to the API. Any necessary `next_cursor` will be automatically populated by\n *   this function. Example: `{ block_id: \"<my block id>\" }`\n */\nexport async function collectPaginatedAPI<Args extends PaginatedArgs, Item>(\n  listFn: (args: Args) => Promise<PaginatedList<Item>>,\n  firstPageArgs: Args\n): Promise<Item[]> {\n  const results: Item[] = []\n  for await (const item of iteratePaginatedAPI(listFn, firstPageArgs)) {\n    results.push(item)\n  }\n  return results\n}\n\n/**\n * @returns `true` if `response` is a full `BlockObjectResponse`.\n */\nexport function isFullBlock(\n  response: BlockObjectResponse | PartialBlockObjectResponse\n): response is BlockObjectResponse {\n  return \"type\" in response\n}\n\n/**\n * @returns `true` if `response` is a full `PageObjectResponse`.\n */\nexport function isFullPage(\n  response: PageObjectResponse | PartialPageObjectResponse\n): response is PageObjectResponse {\n  return \"url\" in response\n}\n\n/**\n * @returns `true` if `response` is a full `DatabaseObjectResponse`.\n */\nexport function isFullDatabase(\n  response: DatabaseObjectResponse | PartialDatabaseObjectResponse\n): response is DatabaseObjectResponse {\n  return \"title\" in response\n}\n\n/**\n * @returns `true` if `response` is a full `UserObjectResponse`.\n */\nexport function isFullUser(\n  response: UserObjectResponse | PartialUserObjectResponse\n): response is UserObjectResponse {\n  return \"type\" in response\n}\n\n/**\n * @returns `true` if `response` is a full `CommentObjectResponse`.\n */\nexport function isFullComment(\n  response: CommentObjectResponse | PartialCommentObjectResponse\n): response is CommentObjectResponse {\n  return \"created_by\" in response\n}\n"]},"metadata":{},"sourceType":"script"}
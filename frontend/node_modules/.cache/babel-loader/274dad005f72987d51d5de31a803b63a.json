{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildRequestError = exports.APIResponseError = exports.UnknownHTTPResponseError = exports.isHTTPResponseError = exports.RequestTimeoutError = exports.isNotionClientError = exports.ClientErrorCode = exports.APIErrorCode = void 0;\n\nconst utils_1 = require(\"./utils\");\n/**\n * Error codes returned in responses from the API.\n */\n\n\nvar APIErrorCode;\n\n(function (APIErrorCode) {\n  APIErrorCode[\"Unauthorized\"] = \"unauthorized\";\n  APIErrorCode[\"RestrictedResource\"] = \"restricted_resource\";\n  APIErrorCode[\"ObjectNotFound\"] = \"object_not_found\";\n  APIErrorCode[\"RateLimited\"] = \"rate_limited\";\n  APIErrorCode[\"InvalidJSON\"] = \"invalid_json\";\n  APIErrorCode[\"InvalidRequestURL\"] = \"invalid_request_url\";\n  APIErrorCode[\"InvalidRequest\"] = \"invalid_request\";\n  APIErrorCode[\"ValidationError\"] = \"validation_error\";\n  APIErrorCode[\"ConflictError\"] = \"conflict_error\";\n  APIErrorCode[\"InternalServerError\"] = \"internal_server_error\";\n  APIErrorCode[\"ServiceUnavailable\"] = \"service_unavailable\";\n})(APIErrorCode = exports.APIErrorCode || (exports.APIErrorCode = {}));\n/**\n * Error codes generated for client errors.\n */\n\n\nvar ClientErrorCode;\n\n(function (ClientErrorCode) {\n  ClientErrorCode[\"RequestTimeout\"] = \"notionhq_client_request_timeout\";\n  ClientErrorCode[\"ResponseError\"] = \"notionhq_client_response_error\";\n})(ClientErrorCode = exports.ClientErrorCode || (exports.ClientErrorCode = {}));\n/**\n * Base error type.\n */\n\n\nclass NotionClientErrorBase extends Error {}\n/**\n * @param error any value, usually a caught error.\n * @returns `true` if error is a `NotionClientError`.\n */\n\n\nfunction isNotionClientError(error) {\n  return (0, utils_1.isObject)(error) && error instanceof NotionClientErrorBase;\n}\n\nexports.isNotionClientError = isNotionClientError;\n/**\n * Narrows down the types of a NotionClientError.\n * @param error any value, usually a caught error.\n * @param codes an object mapping from possible error codes to `true`\n * @returns `true` if error is a `NotionClientError` with a code in `codes`.\n */\n\nfunction isNotionClientErrorWithCode(error, codes) {\n  return isNotionClientError(error) && error.code in codes;\n}\n/**\n * Error thrown by the client if a request times out.\n */\n\n\nclass RequestTimeoutError extends NotionClientErrorBase {\n  constructor() {\n    let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Request to Notion API has timed out\";\n    super(message);\n    this.code = ClientErrorCode.RequestTimeout;\n    this.name = \"RequestTimeoutError\";\n  }\n\n  static isRequestTimeoutError(error) {\n    return isNotionClientErrorWithCode(error, {\n      [ClientErrorCode.RequestTimeout]: true\n    });\n  }\n\n  static rejectAfterTimeout(promise, timeoutMS) {\n    return new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        reject(new RequestTimeoutError());\n      }, timeoutMS);\n      promise.then(resolve).catch(reject).then(() => clearTimeout(timeoutId));\n    });\n  }\n\n}\n\nexports.RequestTimeoutError = RequestTimeoutError;\n\nclass HTTPResponseError extends NotionClientErrorBase {\n  constructor(args) {\n    super(args.message);\n    this.name = \"HTTPResponseError\";\n    const {\n      code,\n      status,\n      headers,\n      rawBodyText\n    } = args;\n    this.code = code;\n    this.status = status;\n    this.headers = headers;\n    this.body = rawBodyText;\n  }\n\n}\n\nconst httpResponseErrorCodes = {\n  [ClientErrorCode.ResponseError]: true,\n  [APIErrorCode.Unauthorized]: true,\n  [APIErrorCode.RestrictedResource]: true,\n  [APIErrorCode.ObjectNotFound]: true,\n  [APIErrorCode.RateLimited]: true,\n  [APIErrorCode.InvalidJSON]: true,\n  [APIErrorCode.InvalidRequestURL]: true,\n  [APIErrorCode.InvalidRequest]: true,\n  [APIErrorCode.ValidationError]: true,\n  [APIErrorCode.ConflictError]: true,\n  [APIErrorCode.InternalServerError]: true,\n  [APIErrorCode.ServiceUnavailable]: true\n};\n\nfunction isHTTPResponseError(error) {\n  if (!isNotionClientErrorWithCode(error, httpResponseErrorCodes)) {\n    return false;\n  }\n\n  return true;\n}\n\nexports.isHTTPResponseError = isHTTPResponseError;\n/**\n * Error thrown if an API call responds with an unknown error code, or does not respond with\n * a property-formatted error.\n */\n\nclass UnknownHTTPResponseError extends HTTPResponseError {\n  constructor(args) {\n    var _a;\n\n    super({ ...args,\n      code: ClientErrorCode.ResponseError,\n      message: (_a = args.message) !== null && _a !== void 0 ? _a : `Request to Notion API failed with status: ${args.status}`\n    });\n    this.name = \"UnknownHTTPResponseError\";\n  }\n\n  static isUnknownHTTPResponseError(error) {\n    return isNotionClientErrorWithCode(error, {\n      [ClientErrorCode.ResponseError]: true\n    });\n  }\n\n}\n\nexports.UnknownHTTPResponseError = UnknownHTTPResponseError;\nconst apiErrorCodes = {\n  [APIErrorCode.Unauthorized]: true,\n  [APIErrorCode.RestrictedResource]: true,\n  [APIErrorCode.ObjectNotFound]: true,\n  [APIErrorCode.RateLimited]: true,\n  [APIErrorCode.InvalidJSON]: true,\n  [APIErrorCode.InvalidRequestURL]: true,\n  [APIErrorCode.InvalidRequest]: true,\n  [APIErrorCode.ValidationError]: true,\n  [APIErrorCode.ConflictError]: true,\n  [APIErrorCode.InternalServerError]: true,\n  [APIErrorCode.ServiceUnavailable]: true\n};\n/**\n * A response from the API indicating a problem.\n * Use the `code` property to handle various kinds of errors. All its possible values are in `APIErrorCode`.\n */\n\nclass APIResponseError extends HTTPResponseError {\n  constructor() {\n    super(...arguments);\n    this.name = \"APIResponseError\";\n  }\n\n  static isAPIResponseError(error) {\n    return isNotionClientErrorWithCode(error, apiErrorCodes);\n  }\n\n}\n\nexports.APIResponseError = APIResponseError;\n\nfunction buildRequestError(response, bodyText) {\n  const apiErrorResponseBody = parseAPIErrorResponseBody(bodyText);\n\n  if (apiErrorResponseBody !== undefined) {\n    return new APIResponseError({\n      code: apiErrorResponseBody.code,\n      message: apiErrorResponseBody.message,\n      headers: response.headers,\n      status: response.status,\n      rawBodyText: bodyText\n    });\n  }\n\n  return new UnknownHTTPResponseError({\n    message: undefined,\n    headers: response.headers,\n    status: response.status,\n    rawBodyText: bodyText\n  });\n}\n\nexports.buildRequestError = buildRequestError;\n\nfunction parseAPIErrorResponseBody(body) {\n  if (typeof body !== \"string\") {\n    return;\n  }\n\n  let parsed;\n\n  try {\n    parsed = JSON.parse(body);\n  } catch (parseError) {\n    return;\n  }\n\n  if (!(0, utils_1.isObject)(parsed) || typeof parsed[\"message\"] !== \"string\" || !isAPIErrorCode(parsed[\"code\"])) {\n    return;\n  }\n\n  return { ...parsed,\n    code: parsed[\"code\"],\n    message: parsed[\"message\"]\n  };\n}\n\nfunction isAPIErrorCode(code) {\n  return typeof code === \"string\" && code in apiErrorCodes;\n}","map":{"version":3,"mappings":";;;;;;;AACA;AAGA;;;;;AAGA,IAAYA,YAAZ;;AAAA,WAAYA,YAAZ,EAAwB;EACtBA;EACAA;EACAA;EACAA;EACAA;EACAA;EACAA;EACAA;EACAA;EACAA;EACAA;AACD,CAZD,EAAYA,YAAY,GAAZC,gDAAY,EAAZ,CAAZ;AAcA;;;;;AAGA,IAAYC,eAAZ;;AAAA,WAAYA,eAAZ,EAA2B;EACzBA;EACAA;AACD,CAHD,EAAYA,eAAe,GAAfD,sDAAe,EAAf,CAAZ;AAUA;;;;;AAGA,MAAeE,qBAAf,SAEUC,KAFV,CAEe;AAuBf;;;;;;AAIA,SAAgBC,mBAAhB,CACEC,KADF,EACgB;EAEd,OAAO,sBAASA,KAAT,KAAmBA,KAAK,YAAYH,qBAA3C;AACD;;AAJDF;AAMA;;;;;;;AAMA,SAASM,2BAAT,CACED,KADF,EAEEE,KAFF,EAE8B;EAE5B,OAAOH,mBAAmB,CAACC,KAAD,CAAnB,IAA8BA,KAAK,CAACG,IAAN,IAAcD,KAAnD;AACD;AAED;;;;;AAGA,MAAaE,mBAAb,SAAyCP,qBAAzC,CAA8F;EAI5FQ,cAA2D;IAAA,IAA/CC,OAA+C,uEAArC,qCAAqC;IACzD,MAAMA,OAAN;IAJO,YAAOV,eAAe,CAACW,cAAvB;IACA,YAAO,qBAAP;EAIR;;EAE2B,OAArBC,qBAAqB,CAACR,KAAD,EAAe;IACzC,OAAOC,2BAA2B,CAACD,KAAD,EAAQ;MACxC,CAACJ,eAAe,CAACW,cAAjB,GAAkC;IADM,CAAR,CAAlC;EAGD;;EAEwB,OAAlBE,kBAAkB,CACvBC,OADuB,EAEvBC,SAFuB,EAEN;IAEjB,OAAO,IAAIC,OAAJ,CAAe,CAACC,OAAD,EAAUC,MAAV,KAAoB;MACxC,MAAMC,SAAS,GAAGC,UAAU,CAAC,MAAK;QAChCF,MAAM,CAAC,IAAIV,mBAAJ,EAAD,CAAN;MACD,CAF2B,EAEzBO,SAFyB,CAA5B;MAIAD,OAAO,CACJO,IADH,CACQJ,OADR,EAEGK,KAFH,CAESJ,MAFT,EAGGG,IAHH,CAGQ,MAAME,YAAY,CAACJ,SAAD,CAH1B;IAID,CATM,CAAP;EAUD;;AA5B2F;;AAA9FpB;;AAiCA,MAAMyB,iBAAN,SAEUvB,qBAFV,CAEqC;EAOnCQ,YAAYgB,IAAZ,EAMC;IACC,MAAMA,IAAI,CAACf,OAAX;IAbO,YAAe,mBAAf;IAcP,MAAM;MAAEH,IAAF;MAAQmB,MAAR;MAAgBC,OAAhB;MAAyBC;IAAzB,IAAyCH,IAA/C;IACA,KAAKlB,IAAL,GAAYA,IAAZ;IACA,KAAKmB,MAAL,GAAcA,MAAd;IACA,KAAKC,OAAL,GAAeA,OAAf;IACA,KAAKE,IAAL,GAAYD,WAAZ;EACD;;AApBkC;;AAuBrC,MAAME,sBAAsB,GAA2C;EACrE,CAAC9B,eAAe,CAAC+B,aAAjB,GAAiC,IADoC;EAErE,CAACjC,YAAY,CAACkC,YAAd,GAA6B,IAFwC;EAGrE,CAAClC,YAAY,CAACmC,kBAAd,GAAmC,IAHkC;EAIrE,CAACnC,YAAY,CAACoC,cAAd,GAA+B,IAJsC;EAKrE,CAACpC,YAAY,CAACqC,WAAd,GAA4B,IALyC;EAMrE,CAACrC,YAAY,CAACsC,WAAd,GAA4B,IANyC;EAOrE,CAACtC,YAAY,CAACuC,iBAAd,GAAkC,IAPmC;EAQrE,CAACvC,YAAY,CAACwC,cAAd,GAA+B,IARsC;EASrE,CAACxC,YAAY,CAACyC,eAAd,GAAgC,IATqC;EAUrE,CAACzC,YAAY,CAAC0C,aAAd,GAA8B,IAVuC;EAWrE,CAAC1C,YAAY,CAAC2C,mBAAd,GAAoC,IAXiC;EAYrE,CAAC3C,YAAY,CAAC4C,kBAAd,GAAmC;AAZkC,CAAvE;;AAeA,SAAgBC,mBAAhB,CACEvC,KADF,EACgB;EAEd,IAAI,CAACC,2BAA2B,CAACD,KAAD,EAAQ0B,sBAAR,CAAhC,EAAiE;IAC/D,OAAO,KAAP;EACD;;EAOD,OAAO,IAAP;AACD;;AAbD/B;AAeA;;;;;AAIA,MAAa6C,wBAAb,SAA8CpB,iBAA9C,CAA8F;EAG5Ff,YAAYgB,IAAZ,EAKC;;;IACC,MAAM,EACJ,GAAGA,IADC;MAEJlB,IAAI,EAAEP,eAAe,CAAC+B,aAFlB;MAGJrB,OAAO,EACL,UAAI,CAACA,OAAL,MAAY,IAAZ,IAAYmC,aAAZ,GAAYA,EAAZ,GACA,6CAA6CpB,IAAI,CAACC,MAAM;IALtD,CAAN;IARO,YAAO,0BAAP;EAeR;;EAEgC,OAA1BoB,0BAA0B,CAC/B1C,KAD+B,EACjB;IAEd,OAAOC,2BAA2B,CAACD,KAAD,EAAQ;MACxC,CAACJ,eAAe,CAAC+B,aAAjB,GAAiC;IADO,CAAR,CAAlC;EAGD;;AAxB2F;;AAA9FhC;AA2BA,MAAMgD,aAAa,GAAkC;EACnD,CAACjD,YAAY,CAACkC,YAAd,GAA6B,IADsB;EAEnD,CAAClC,YAAY,CAACmC,kBAAd,GAAmC,IAFgB;EAGnD,CAACnC,YAAY,CAACoC,cAAd,GAA+B,IAHoB;EAInD,CAACpC,YAAY,CAACqC,WAAd,GAA4B,IAJuB;EAKnD,CAACrC,YAAY,CAACsC,WAAd,GAA4B,IALuB;EAMnD,CAACtC,YAAY,CAACuC,iBAAd,GAAkC,IANiB;EAOnD,CAACvC,YAAY,CAACwC,cAAd,GAA+B,IAPoB;EAQnD,CAACxC,YAAY,CAACyC,eAAd,GAAgC,IARmB;EASnD,CAACzC,YAAY,CAAC0C,aAAd,GAA8B,IATqB;EAUnD,CAAC1C,YAAY,CAAC2C,mBAAd,GAAoC,IAVe;EAWnD,CAAC3C,YAAY,CAAC4C,kBAAd,GAAmC;AAXgB,CAArD;AAcA;;;;;AAIA,MAAaM,gBAAb,SAAsCxB,iBAAtC,CAAqE;EAArEf;;IACW,YAAO,kBAAP;EAKV;;EAH0B,OAAlBwC,kBAAkB,CAAC7C,KAAD,EAAe;IACtC,OAAOC,2BAA2B,CAACD,KAAD,EAAQ2C,aAAR,CAAlC;EACD;;AALkE;;AAArEhD;;AAQA,SAAgBmD,iBAAhB,CACEC,QADF,EAEEC,QAFF,EAEkB;EAEhB,MAAMC,oBAAoB,GAAGC,yBAAyB,CAACF,QAAD,CAAtD;;EACA,IAAIC,oBAAoB,KAAKE,SAA7B,EAAwC;IACtC,OAAO,IAAIP,gBAAJ,CAAqB;MAC1BzC,IAAI,EAAE8C,oBAAoB,CAAC9C,IADD;MAE1BG,OAAO,EAAE2C,oBAAoB,CAAC3C,OAFJ;MAG1BiB,OAAO,EAAEwB,QAAQ,CAACxB,OAHQ;MAI1BD,MAAM,EAAEyB,QAAQ,CAACzB,MAJS;MAK1BE,WAAW,EAAEwB;IALa,CAArB,CAAP;EAOD;;EACD,OAAO,IAAIR,wBAAJ,CAA6B;IAClClC,OAAO,EAAE6C,SADyB;IAElC5B,OAAO,EAAEwB,QAAQ,CAACxB,OAFgB;IAGlCD,MAAM,EAAEyB,QAAQ,CAACzB,MAHiB;IAIlCE,WAAW,EAAEwB;EAJqB,CAA7B,CAAP;AAMD;;AApBDrD;;AAsBA,SAASuD,yBAAT,CACEzB,IADF,EACc;EAEZ,IAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;IAC5B;EACD;;EAED,IAAI2B,MAAJ;;EACA,IAAI;IACFA,MAAM,GAAGC,IAAI,CAACC,KAAL,CAAW7B,IAAX,CAAT;EACD,CAFD,CAEE,OAAO8B,UAAP,EAAmB;IACnB;EACD;;EAED,IACE,CAAC,sBAASH,MAAT,CAAD,IACA,OAAOA,MAAM,CAAC,SAAD,CAAb,KAA6B,QAD7B,IAEA,CAACI,cAAc,CAACJ,MAAM,CAAC,MAAD,CAAP,CAHjB,EAIE;IACA;EACD;;EAED,OAAO,EACL,GAAGA,MADE;IAELjD,IAAI,EAAEiD,MAAM,CAAC,MAAD,CAFP;IAGL9C,OAAO,EAAE8C,MAAM,CAAC,SAAD;EAHV,CAAP;AAKD;;AAED,SAASI,cAAT,CAAwBrD,IAAxB,EAAqC;EACnC,OAAO,OAAOA,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,IAAIwC,aAA3C;AACD","names":["APIErrorCode","exports","ClientErrorCode","NotionClientErrorBase","Error","isNotionClientError","error","isNotionClientErrorWithCode","codes","code","RequestTimeoutError","constructor","message","RequestTimeout","isRequestTimeoutError","rejectAfterTimeout","promise","timeoutMS","Promise","resolve","reject","timeoutId","setTimeout","then","catch","clearTimeout","HTTPResponseError","args","status","headers","rawBodyText","body","httpResponseErrorCodes","ResponseError","Unauthorized","RestrictedResource","ObjectNotFound","RateLimited","InvalidJSON","InvalidRequestURL","InvalidRequest","ValidationError","ConflictError","InternalServerError","ServiceUnavailable","isHTTPResponseError","UnknownHTTPResponseError","_a","isUnknownHTTPResponseError","apiErrorCodes","APIResponseError","isAPIResponseError","buildRequestError","response","bodyText","apiErrorResponseBody","parseAPIErrorResponseBody","undefined","parsed","JSON","parse","parseError","isAPIErrorCode"],"sources":["/home/tan/flash-card/node_modules/@notionhq/client/src/errors.ts"],"sourcesContent":["import { SupportedResponse } from \"./fetch-types\"\nimport { isObject } from \"./utils\"\nimport { Assert } from \"./type-utils\"\n\n/**\n * Error codes returned in responses from the API.\n */\nexport enum APIErrorCode {\n  Unauthorized = \"unauthorized\",\n  RestrictedResource = \"restricted_resource\",\n  ObjectNotFound = \"object_not_found\",\n  RateLimited = \"rate_limited\",\n  InvalidJSON = \"invalid_json\",\n  InvalidRequestURL = \"invalid_request_url\",\n  InvalidRequest = \"invalid_request\",\n  ValidationError = \"validation_error\",\n  ConflictError = \"conflict_error\",\n  InternalServerError = \"internal_server_error\",\n  ServiceUnavailable = \"service_unavailable\",\n}\n\n/**\n * Error codes generated for client errors.\n */\nexport enum ClientErrorCode {\n  RequestTimeout = \"notionhq_client_request_timeout\",\n  ResponseError = \"notionhq_client_response_error\",\n}\n\n/**\n * Error codes on errors thrown by the `Client`.\n */\nexport type NotionErrorCode = APIErrorCode | ClientErrorCode\n\n/**\n * Base error type.\n */\nabstract class NotionClientErrorBase<\n  Code extends NotionErrorCode\n> extends Error {\n  abstract code: Code\n}\n\n/**\n * Error type that encompasses all the kinds of errors that the Notion client will throw.\n */\nexport type NotionClientError =\n  | RequestTimeoutError\n  | UnknownHTTPResponseError\n  | APIResponseError\n\n// Assert that NotionClientError's `code` property is a narrow type.\n// This prevents us from accidentally regressing to `string`-typed name field.\ntype _assertCodeIsNarrow = Assert<NotionErrorCode, NotionClientError[\"code\"]>\n\n// Assert that the type of `name` in NotionErrorCode is a narrow type.\n// This prevents us from accidentally regressing to `string`-typed name field.\ntype _assertNameIsNarrow = Assert<\n  \"RequestTimeoutError\" | \"UnknownHTTPResponseError\" | \"APIResponseError\",\n  NotionClientError[\"name\"]\n>\n\n/**\n * @param error any value, usually a caught error.\n * @returns `true` if error is a `NotionClientError`.\n */\nexport function isNotionClientError(\n  error: unknown\n): error is NotionClientError {\n  return isObject(error) && error instanceof NotionClientErrorBase\n}\n\n/**\n * Narrows down the types of a NotionClientError.\n * @param error any value, usually a caught error.\n * @param codes an object mapping from possible error codes to `true`\n * @returns `true` if error is a `NotionClientError` with a code in `codes`.\n */\nfunction isNotionClientErrorWithCode<Code extends NotionErrorCode>(\n  error: unknown,\n  codes: { [C in Code]: true }\n): error is NotionClientError & { code: Code } {\n  return isNotionClientError(error) && error.code in codes\n}\n\n/**\n * Error thrown by the client if a request times out.\n */\nexport class RequestTimeoutError extends NotionClientErrorBase<ClientErrorCode.RequestTimeout> {\n  readonly code = ClientErrorCode.RequestTimeout\n  readonly name = \"RequestTimeoutError\"\n\n  constructor(message = \"Request to Notion API has timed out\") {\n    super(message)\n  }\n\n  static isRequestTimeoutError(error: unknown): error is RequestTimeoutError {\n    return isNotionClientErrorWithCode(error, {\n      [ClientErrorCode.RequestTimeout]: true,\n    })\n  }\n\n  static rejectAfterTimeout<T>(\n    promise: Promise<T>,\n    timeoutMS: number\n  ): Promise<T> {\n    return new Promise<T>((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        reject(new RequestTimeoutError())\n      }, timeoutMS)\n\n      promise\n        .then(resolve)\n        .catch(reject)\n        .then(() => clearTimeout(timeoutId))\n    })\n  }\n}\n\ntype HTTPResponseErrorCode = ClientErrorCode.ResponseError | APIErrorCode\n\nclass HTTPResponseError<\n  Code extends HTTPResponseErrorCode\n> extends NotionClientErrorBase<Code> {\n  readonly name: string = \"HTTPResponseError\"\n  readonly code: Code\n  readonly status: number\n  readonly headers: SupportedResponse[\"headers\"]\n  readonly body: string\n\n  constructor(args: {\n    code: Code\n    status: number\n    message: string\n    headers: SupportedResponse[\"headers\"]\n    rawBodyText: string\n  }) {\n    super(args.message)\n    const { code, status, headers, rawBodyText } = args\n    this.code = code\n    this.status = status\n    this.headers = headers\n    this.body = rawBodyText\n  }\n}\n\nconst httpResponseErrorCodes: { [C in HTTPResponseErrorCode]: true } = {\n  [ClientErrorCode.ResponseError]: true,\n  [APIErrorCode.Unauthorized]: true,\n  [APIErrorCode.RestrictedResource]: true,\n  [APIErrorCode.ObjectNotFound]: true,\n  [APIErrorCode.RateLimited]: true,\n  [APIErrorCode.InvalidJSON]: true,\n  [APIErrorCode.InvalidRequestURL]: true,\n  [APIErrorCode.InvalidRequest]: true,\n  [APIErrorCode.ValidationError]: true,\n  [APIErrorCode.ConflictError]: true,\n  [APIErrorCode.InternalServerError]: true,\n  [APIErrorCode.ServiceUnavailable]: true,\n}\n\nexport function isHTTPResponseError(\n  error: unknown\n): error is UnknownHTTPResponseError | APIResponseError {\n  if (!isNotionClientErrorWithCode(error, httpResponseErrorCodes)) {\n    return false\n  }\n\n  type _assert = Assert<\n    UnknownHTTPResponseError | APIResponseError,\n    typeof error\n  >\n\n  return true\n}\n\n/**\n * Error thrown if an API call responds with an unknown error code, or does not respond with\n * a property-formatted error.\n */\nexport class UnknownHTTPResponseError extends HTTPResponseError<ClientErrorCode.ResponseError> {\n  readonly name = \"UnknownHTTPResponseError\"\n\n  constructor(args: {\n    status: number\n    message: string | undefined\n    headers: SupportedResponse[\"headers\"]\n    rawBodyText: string\n  }) {\n    super({\n      ...args,\n      code: ClientErrorCode.ResponseError,\n      message:\n        args.message ??\n        `Request to Notion API failed with status: ${args.status}`,\n    })\n  }\n\n  static isUnknownHTTPResponseError(\n    error: unknown\n  ): error is UnknownHTTPResponseError {\n    return isNotionClientErrorWithCode(error, {\n      [ClientErrorCode.ResponseError]: true,\n    })\n  }\n}\n\nconst apiErrorCodes: { [C in APIErrorCode]: true } = {\n  [APIErrorCode.Unauthorized]: true,\n  [APIErrorCode.RestrictedResource]: true,\n  [APIErrorCode.ObjectNotFound]: true,\n  [APIErrorCode.RateLimited]: true,\n  [APIErrorCode.InvalidJSON]: true,\n  [APIErrorCode.InvalidRequestURL]: true,\n  [APIErrorCode.InvalidRequest]: true,\n  [APIErrorCode.ValidationError]: true,\n  [APIErrorCode.ConflictError]: true,\n  [APIErrorCode.InternalServerError]: true,\n  [APIErrorCode.ServiceUnavailable]: true,\n}\n\n/**\n * A response from the API indicating a problem.\n * Use the `code` property to handle various kinds of errors. All its possible values are in `APIErrorCode`.\n */\nexport class APIResponseError extends HTTPResponseError<APIErrorCode> {\n  readonly name = \"APIResponseError\"\n\n  static isAPIResponseError(error: unknown): error is APIResponseError {\n    return isNotionClientErrorWithCode(error, apiErrorCodes)\n  }\n}\n\nexport function buildRequestError(\n  response: SupportedResponse,\n  bodyText: string\n): APIResponseError | UnknownHTTPResponseError {\n  const apiErrorResponseBody = parseAPIErrorResponseBody(bodyText)\n  if (apiErrorResponseBody !== undefined) {\n    return new APIResponseError({\n      code: apiErrorResponseBody.code,\n      message: apiErrorResponseBody.message,\n      headers: response.headers,\n      status: response.status,\n      rawBodyText: bodyText,\n    })\n  }\n  return new UnknownHTTPResponseError({\n    message: undefined,\n    headers: response.headers,\n    status: response.status,\n    rawBodyText: bodyText,\n  })\n}\n\nfunction parseAPIErrorResponseBody(\n  body: string\n): { code: APIErrorCode; message: string } | undefined {\n  if (typeof body !== \"string\") {\n    return\n  }\n\n  let parsed: unknown\n  try {\n    parsed = JSON.parse(body)\n  } catch (parseError) {\n    return\n  }\n\n  if (\n    !isObject(parsed) ||\n    typeof parsed[\"message\"] !== \"string\" ||\n    !isAPIErrorCode(parsed[\"code\"])\n  ) {\n    return\n  }\n\n  return {\n    ...parsed,\n    code: parsed[\"code\"],\n    message: parsed[\"message\"],\n  }\n}\n\nfunction isAPIErrorCode(code: unknown): code is APIErrorCode {\n  return typeof code === \"string\" && code in apiErrorCodes\n}\n"]},"metadata":{},"sourceType":"script"}